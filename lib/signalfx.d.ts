export interface SignalFlowClientOptions {
    signalflowEndpoint: string;
    webSocketErrorCallback?: (error: any) => void;
}

export interface ExecuteOptions {
    program: string;
    start?: number;
    stop?: number;
    resolution?: number;
    offsetByMaxDelay?: boolean;
    maxDelay?: number;
    immediate?: boolean;
    usedByDetectorUI?: boolean;
    useCache?: boolean;
    compress?: boolean;
}

type SignalFlow = (token: string, options: SignalFlowClientOptions) => SignalFlowClient;

export const SignalFlow: SignalFlow;
export type Streamer = {
    SignalFlow: SignalFlow;
};

export const streamer: Streamer;

type StreamControlMessageStreamStart = {
    event: 'STREAM_START' | 'END_OF_CHANNEL';
};

type StreamControlMessageJobStart = {
    event: 'JOB_START';
    handle: string;
};

type StreamControlMessageJobProgress = {
    event: 'JOB_PROGRESS';
    progress: number;
};

/**
 * Provide information about the stream itself
 */
type StreamControlMessage = {
    type: 'control-message';
    channel: string;
    timestampMs: number;
} & (
    | StreamControlMessageStreamStart
    | StreamControlMessageJobStart
    | StreamControlMessageJobProgress
);

/**
 * Metadata messages contain the metadata from the output time series of your computation.
 */
type StreamMetadataMessage = {
    type: 'metadata';
    channel: string;
    tsId: string;
    properties: {
        jobId: string;
        sf_organizationID: string;
        sf_streamLabel?: string;
        sf_key: string[];
        sf_metric: string;
        sf_originatingMetric: string;
        sf_resolutionMs: number;
        sf_type: string;
        sf_isPreQuantized: boolean;
        sf_tags?: string[];
    } & Record<string, string>;
};

/**
 * Expired TSID messages indicate that a specific output timeseries is probably no longer useful for the computation.
 */
type StreamExpiredTSIDMessage = {
    type: 'expired-tsid';
    channel: string;
    tsId: string;
};

type StreamDataPoint = {
    tsId: string;
    value: number;
};

/**
 * Data messages contain the actual timeseries results generated by the computation.
 */
type StreamDataMessage = {
    type: 'data';
    data: StreamDataPoint[];
    logicalTimestampMs: number;
};

type EventState = 'ok' | 'anomalous' | 'manually_resolved' | 'stopped';

/**
 * Sent when an anomaly triggers a SignalFx detector, or when the triggered detector resolves
 */
type StreamEventMessage = {
    type: 'event';
    channel: string;
    properties: {
        incidentId: string;
        inputValues: string;
        is: EventState;
        was: EventState;
    };
    timestampMs: number;
    tsId: string;
};

type StreamMessageMessage = {
    type: 'message';
    channel: string;
    logicalTimestampMs: number;
    message: {
        messageCode: string;
        messageLevel: string;
        numInputTimeSeries: number;
        timestampMs: number;
        blockContexts: Array<{ column: number; line: number }>;
    };
};

/**
 * Union of all stream messages.
 */
type StreamMessage =
    | StreamControlMessage
    | StreamMetadataMessage
    | StreamExpiredTSIDMessage
    | StreamDataMessage
    | StreamEventMessage
    | StreamLogDataMessage
    | StreamLiveTailStartedMessage
    | StreamMessageMessage;

export type StreamError = {
    type: 'error';
    channel: string;
    context: any;
    error: number;
    errorType: 'ANALYTICS_PROGRAM_NAME_ERROR';
    message: string | null;
    errors?: { code: string }[];
};

type StreamCallback = (error: StreamError | undefined, message: StreamMessage | undefined) => void;

interface LiveTailOptions {
    query: object;
    throttleOptions: object;
}
interface SignalFlowClient {
    execute(opts: ExecuteOptions): Stream;
    disconnect(): void;
    livetail(opts: LiveTailOptions): LiveTail | undefined;
    initialized?: boolean;
}

interface Stream {
    stream(fn: StreamCallback): boolean;
    close(): boolean;

    // eslint-disable-next-line @typescript-eslint/camelcase
    get_known_tsids(): string[];
    // eslint-disable-next-line @typescript-eslint/camelcase
    get_metadata(tsId: string): StreamMetadataMessage;
}

interface LiveTail {
    stream(fn: StreamCallback): boolean;
    close(): boolean;
}

export type LiveTailResult = {
    id: string;
    _raw: string;
    _time: string;
    [key: string]: string | number;
};

export type StreamLogDataMessage = {
    type: 'log-data';
    results: LiveTailResult[];
    metadata: LiveTailMetadata;
};

export declare type LiveTailMetadata = {
    eventsMatched: number;
    eventsSent: number;
};

export type StreamLiveTailStartedMessage = {
    type: 'livetail-started';
    channel: string;
    timestampMs: number;
};
